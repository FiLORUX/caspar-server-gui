<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>TSG | Key + Fill Ident Programme</title>
  <style>
    /*
     * KEY/FILL CHANNEL IDENTIFIER
     *
     * Three-layer design philosophy:
     * 1. FILL monitor alone  → sees "FILL" text, colourful graphics, channel ID
     * 2. KEY monitor alone   → sees "KEY" text as white matte, different animation
     * 3. COMBINED (DSK)      → sees BOTH texts + "PAIRED" reveal + merged animations
     *
     * The magic: Fill RGB × Key luminance = Combined output
     * - Where Key is white (1.0) → Fill colour shows through
     * - Where Key is black (0.0) → Transparent (background shows)
     *
     * Design principle: Every pixel is considered for all three viewing modes.
     */

    :root {
      /* Broadcast-safe colours (staying within 16-235 range feel) */
      --fill-accent: #00d4ff;
      --fill-accent-rgb: 0, 212, 255;
      --fill-secondary: #ff6b35;
      --fill-secondary-rgb: 255, 107, 53;
      --key-white: #ffffff;
      --panel-bg: rgba(0, 0, 0, 0.85);
      --panel-border: rgba(255, 255, 255, 0.15);

      /* Typography */
      --font-mono: 'SF Mono', 'Cascadia Code', 'Fira Code', 'Consolas', monospace;
      --font-display: 'Inter', 'SF Pro Display', -apple-system, system-ui, sans-serif;

      /* Sizing */
      --safe-margin: 3.5%;
    }

    *, *::before, *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      /* CRITICAL: transparent background for CasparCG alpha channel */
      background: transparent;
    }

    /* Preview mode: checkerboard shows transparency (like Photoshop) */
    .stage.preview {
      background:
        linear-gradient(45deg, #1a1a1a 25%, transparent 25%),
        linear-gradient(-45deg, #1a1a1a 25%, transparent 25%),
        linear-gradient(45deg, transparent 75%, #1a1a1a 75%),
        linear-gradient(-45deg, transparent 75%, #1a1a1a 75%),
        #0d0d0d;
      background-size: var(--checker-size) var(--checker-size);
      background-position: 0 0, 0 calc(var(--checker-size) / 2),
        calc(var(--checker-size) / 2) calc(var(--checker-size) / -2),
        calc(var(--checker-size) / -2) 0;
    }

    .stage {
      position: relative;
      width: 100vw;
      height: 100vh;
      background: transparent;
      font-family: var(--font-display);
      --bar-height: clamp(10px, 1.6vmin, 18px);
    }
    html.fill-mode,
    body.fill-mode {
      background: #000;
    }
    .stage.key {
      /* KEY should look like a key signal: black bg, white matte */
      background: #000;
      --key-ten: #1A1A1A;
      --key-ninety: #E6E6E6;
      --key-seventyfive: #BFBFBF;
    }

    /* ═══════════════════════════════════════════════════════════════
       FILL MODE SPECIFIC STYLES
       These elements appear in fill output, provide RGB colour data
       ═══════════════════════════════════════════════════════════════ */

    /* Subtle grid texture - fill and preview only (provides visual richness) */
    .fill-texture {
      position: absolute;
      inset: 0;
      background:
        linear-gradient(90deg, rgba(255,255,255,0.03) 1px, transparent 1px),
        linear-gradient(rgba(255,255,255,0.03) 1px, transparent 1px);
      background-size: var(--checker-size) var(--checker-size);
      pointer-events: none;
    }
    .stage.key .fill-texture { display: none; }
    .stage.preview .fill-texture { opacity: 0.5; }

    /* Gradient sweep - fill only */
    .fill-sweep {
      position: absolute;
      inset: 0;
      background: linear-gradient(
        135deg,
        rgba(0, 212, 255, 0.08) 0%,
        transparent 40%,
        transparent 60%,
        rgba(255, 107, 53, 0.06) 100%
      );
      pointer-events: none;
    }
    .stage.key .fill-sweep { display: none; }

    /* ═══════════════════════════════════════════════════════════════
       MAIN LAYOUT STRUCTURE
       ═══════════════════════════════════════════════════════════════ */

    .layout {
      position: absolute;
      inset: var(--safe-margin);
      display: grid;
      grid-template-rows: auto 1fr auto;
      grid-template-columns: 1fr 1fr;
      gap: 2vmin;
      --grid-gap: 2vmin;
      --right-col: calc((100% - var(--grid-gap)) / 2.4);
    }

    /* ═══════════════════════════════════════════════════════════════
       HEADER ZONE - "FILL" and "KEY" labels

       FILL mode: Shows "FILL" text in left box, right box is subtle
       KEY mode:  Shows "KEY" text as matte in right box, left is solid white
       COMBINED:  Both texts visible! Left shows "FILL", right shows "KEY"
       ═══════════════════════════════════════════════════════════════ */

    .header {
      grid-column: 1 / -1;
      display: flex;
      justify-content: flex-end;
      gap: var(--grid-gap);
      height: clamp(60px, 10vmin, 100px);
      position: relative;
    }

    .header-left-decor {
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      display: flex;
      gap: var(--grid-gap);
      align-items: center;
    }

    .header-box {
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 1.5vmin;
      position: relative;
      overflow: hidden;
      width: var(--right-col);
      flex: 0 0 var(--right-col);
    }

    .header-logo {
      height: 100%;
      aspect-ratio: 450 / 380;
      display: flex;
      padding-left: 0.5vmin;
      flex: 0 0 auto;
      color: var(--fill-accent);
    }
    .stage.key .header-logo {
      color: var(--key-white);
    }

    .header-logo svg {
      height: 100%;
      width: auto;
      display: block;
    }

    .header-tagline {
      height: 100%;
      aspect-ratio: 450 / 380;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: space-between;
      text-align: center;
      font-family: var(--font-mono);
      font-weight: 200;
      font-size: clamp(10px, 1.7vmin, 18px);
      line-height: 1.4;
      letter-spacing: 0.15em;
      color: rgba(255, 255, 255, 0.9);
      text-transform: uppercase;
      flex: 0 0 auto;
      white-space: nowrap;
    }

    .header-tagline-strong {
      font-weight: 700;
    }

    .header-tagline > span {
      display: block;
      width: 100%;
      text-align: center;
      white-space: nowrap;
    }

    .header-tagline-strong {
      font-size: 2em;
      letter-spacing: 0.02em;
      white-space: nowrap;
      flex: 0 0 auto;
      display: inline-flex;
      width: auto;
      align-self: center;
      transform: scaleY(1.5);
    }

    .header-tagline-strong,
    .header-tagline-strong * {
      white-space: nowrap;
    }

    .mirror-glyph {
      display: inline-block;
      transform: scaleX(-1);
      width: auto;
    }


    /* LEFT BOX: Contains "FILL" label */
    .header-left {
      background: linear-gradient(135deg, rgba(0,0,0,0.7), rgba(0,0,0,0.9));
      border: 1px solid var(--panel-border);
    }
    .stage.key .header-left {
      /* Key mode: solid white = full alpha, so FILL text shows in combined */
      background: var(--key-ninety);
      border: none;
    }

    .fill-label {
      font-family: var(--font-mono);
      font-size: clamp(18px, 3.5vmin, 36px);
      font-weight: 700;
      letter-spacing: 0.15em;
      color: var(--fill-accent);
      text-shadow: 0 0 20px rgba(var(--fill-accent-rgb), 0.5);
    }
    .stage.key .fill-label {
      /* In key mode, this text is invisible (same as bg) but position preserved */
      color: var(--key-ninety);
      text-shadow: none;
    }

    /* RIGHT BOX: Contains "KEY" label */
    .header-right {
      /* Fill mode: subtle gradient background that will show through key cutout */
      background: linear-gradient(135deg,
        rgba(255, 107, 53, 0.3),
        rgba(255, 107, 53, 0.15),
        rgba(0, 212, 255, 0.2)
      );
      border: 1px solid var(--panel-border);
    }
    .stage.key .header-right {
      /* Key mode: subtle matte fill */
      background: var(--key-ten);
      border: 1px solid var(--key-seventyfive);
    }

    .key-label {
      font-family: var(--font-mono);
      font-size: clamp(18px, 3.5vmin, 36px);
      font-weight: 700;
      letter-spacing: 0.15em;
      /* Fill mode: very subtle, almost invisible */
      color: transparent;
    }
    .stage.key .key-label {
      /* Key mode: bright white matte */
      color: var(--key-white);
    }
    /* Preview: KEY text visible in gradient colours (simulates combined) */
    .stage.preview .key-label {
      color: transparent;
      background: linear-gradient(135deg, var(--fill-secondary), var(--fill-accent));
      -webkit-background-clip: text;
      background-clip: text;
    }

    /* ═══════════════════════════════════════════════════════════════
       MAIN CENTER ZONE - Channel ID + Animation panels
       ═══════════════════════════════════════════════════════════════ */

    .center {
      grid-column: 1 / -1;
      display: grid;
      grid-template-columns: 1.4fr 1fr;
      gap: var(--grid-gap);
    }

    /* ID PANEL - Large channel number */
    .id-panel {
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(0,0,0,0.25));
      border: 1px solid var(--panel-border);
      border-radius: 2vmin;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
    }
    .stage.fill .id-panel {
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(0,0,0,0.25));
      border: 1px solid var(--panel-border);
    }
    .stage.key .id-panel {
      background: var(--key-ten);
      border: none;
    }

    /* Decorative rings behind ID - fill only */
    .id-rings {
      position: absolute;
      width: 80%;
      height: 80%;
      border: 2px solid rgba(var(--fill-accent-rgb), 0.15);
      border-radius: 50%;
      animation: pulse-ring 4s ease-in-out infinite;
    }
    .id-rings::before,
    .id-rings::after {
      content: '';
      position: absolute;
      inset: 10%;
      border: 1px solid rgba(var(--fill-accent-rgb), 0.1);
      border-radius: 50%;
    }
    .id-rings::after {
      inset: 25%;
      border-color: rgba(var(--fill-secondary-rgb), 0.08);
    }
    .stage.key .id-rings { display: none; }

    @keyframes pulse-ring {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.05); opacity: 0.7; }
    }

    .channel-id {
      font-family: var(--font-mono);
      font-size: clamp(120px, 28vmin, 320px);
      font-weight: 800;
      line-height: 0.85;
      color: #ffffff;
      text-shadow:
        0 0 60px rgba(var(--fill-accent-rgb), 0.4),
        0 4px 20px rgba(0, 0, 0, 0.5);
      position: relative;
      z-index: 2;
    }
    .stage.key .channel-id {
      color: var(--key-white);
      text-shadow: none;
    }

    .channel-meta {
      font-family: var(--font-mono);
      font-size: clamp(11px, 1.8vmin, 18px);
      color: rgba(255, 255, 255, 0.5);
      letter-spacing: 0.1em;
      margin-top: 2vmin;
      position: relative;
      z-index: 2;
    }
    .stage.key .channel-meta {
      color: var(--key-white);
    }

    /* ═══════════════════════════════════════════════════════════════
       CHANNEL FINGERPRINT - Unique visual per channel for mismatch detection

       Mathematical basis: 8 channels = 8 segments of 45° each
       Each channel activates ONE segment. If fill and key are mismatched,
       the segments won't align = immediately visible error!

       Also includes a rotating "radar" arm that starts at channel-specific angle.
       ═══════════════════════════════════════════════════════════════ */

    .fingerprint {
      position: absolute;
      bottom: 4vmin;
      left: 50%;
      transform: translateX(-50%);
      width: clamp(80px, 14vmin, 140px);
      height: clamp(80px, 14vmin, 140px);
      z-index: 3;
    }

    .fingerprint-ring {
      position: absolute;
      inset: 0;
      border-radius: 50%;
      border: 2px solid rgba(255, 255, 255, 0.15);
    }
    .stage.key .fingerprint-ring {
      border-color: var(--key-white);
    }

    /* 8 segments - only the active one is highlighted */
    .fingerprint-segment {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 50%;
      height: 4px;
      transform-origin: left center;
      background: rgba(255, 255, 255, 0.08);
      border-radius: 0 2px 2px 0;
    }
    .stage.key .fingerprint-segment {
      background: rgba(255, 255, 255, 0.3);
    }

    /* Active segment - bright and distinctive */
    .fingerprint-segment.active {
      background: linear-gradient(90deg,
        rgba(var(--fill-accent-rgb), 0.9),
        rgba(var(--fill-accent-rgb), 0.4)
      );
      height: 6px;
      box-shadow: 0 0 12px rgba(var(--fill-accent-rgb), 0.6);
    }
    .stage.key .fingerprint-segment.active {
      background: var(--key-white);
      box-shadow: none;
    }

    /* Rotating radar arm - starts at channel-specific angle */
    .fingerprint-radar {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 48%;
      height: 3px;
      transform-origin: left center;
      background: linear-gradient(90deg,
        rgba(var(--fill-secondary-rgb), 0.1),
        rgba(var(--fill-secondary-rgb), 0.9)
      );
      border-radius: 0 2px 2px 0;
      /* Animation applied via JS with channel-specific offset */
    }
    .stage.key .fingerprint-radar {
      background: linear-gradient(90deg,
        rgba(255, 255, 255, 0.1),
        rgba(255, 255, 255, 1)
      );
    }

    /* Center dot */
    .fingerprint-center {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 12%;
      height: 12%;
      transform: translate(-50%, -50%);
      background: var(--fill-accent);
      border-radius: 50%;
      box-shadow: 0 0 10px rgba(var(--fill-accent-rgb), 0.5);
    }
    .stage.key .fingerprint-center {
      background: var(--key-white);
      box-shadow: none;
    }

    /* Channel number in center */
    .fingerprint-id {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-family: var(--font-mono);
      font-size: clamp(10px, 1.8vmin, 16px);
      font-weight: 700;
      color: rgba(0, 0, 0, 0.8);
    }
    .stage.key .fingerprint-id {
      color: var(--key-white);
    }

    /* Segment position labels (N, NE, E, SE, S, SW, W, NW) */
    .fingerprint-labels {
      position: absolute;
      inset: -20%;
      pointer-events: none;
    }

    .fingerprint-label {
      position: absolute;
      font-family: var(--font-mono);
      font-size: clamp(7px, 1vmin, 10px);
      color: rgba(255, 255, 255, 0.25);
      transform: translate(-50%, -50%);
    }
    .fingerprint-label.active {
      color: var(--fill-accent);
      font-weight: 700;
    }
    .stage.key .fingerprint-label {
      color: rgba(255, 255, 255, 0.4);
    }
    .stage.key .fingerprint-label.active {
      color: var(--key-white);
    }

    /* Position each label around the circle */
    .fingerprint-label[data-pos="1"] { top: 10%; left: 50%; }
    .fingerprint-label[data-pos="2"] { top: 20%; left: 80%; }
    .fingerprint-label[data-pos="3"] { top: 50%; left: 90%; }
    .fingerprint-label[data-pos="4"] { top: 80%; left: 80%; }
    .fingerprint-label[data-pos="5"] { top: 90%; left: 50%; }
    .fingerprint-label[data-pos="6"] { top: 80%; left: 20%; }
    .fingerprint-label[data-pos="7"] { top: 50%; left: 10%; }
    .fingerprint-label[data-pos="8"] { top: 20%; left: 20%; }

    /* MOTION PANEL - Split animation area */
    .motion-panel {
      display: grid;
      grid-template-rows: 1fr 1fr;
      gap: 2vmin;
    }

    /* FILL MOTION - Rotating arc (fill-specific animation) */
    .fill-motion {
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(0,0,0,0.25));
      border: 1px solid var(--panel-border);
      border-radius: 2vmin;
      position: relative;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      --label-offset: 9.55%;
    }
    .stage.fill .fill-motion {
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(0,0,0,0.25));
      border: 1px solid var(--panel-border);
    }
    .stage.key .fill-motion {
      /* Key mode: solid white matte */
      background: var(--key-white);
      border: none;
    }

    .rotating-arc {
      width: 70%;
      height: 70%;
      position: relative;
    }

    .arc {
      position: absolute;
      inset: 0;
      border: 4px solid transparent;
      border-radius: 50%;
      border-top-color: var(--fill-accent);
      border-right-color: var(--fill-secondary);
      animation: rotate-arc 3s linear infinite;
      filter: drop-shadow(0 0 10px rgba(var(--fill-accent-rgb), 0.5));
    }
    .arc:nth-child(2) {
      inset: 15%;
      animation-duration: 2.5s;
      animation-direction: reverse;
      border-top-color: var(--fill-secondary);
      border-right-color: var(--fill-accent);
    }
    .arc:nth-child(3) {
      inset: 30%;
      animation-duration: 2s;
      border-width: 3px;
    }
    .arc.key-only {
      display: none;
      inset: 5%;
      animation-duration: 3.2s;
      animation-direction: reverse;
      border: 3px solid #000000;
      border-top-color: #000000;
      border-right-color: #000000;
      filter: none;
    }
    .stage.key .arc {
      border-top-color: var(--key-white);
      border-right-color: var(--key-white);
      filter: none;
    }
    .stage.key .arc.key-only {
      display: block;
      border-color: #000000;
      border-top-color: #000000;
      border-right-color: #000000;
      background: none;
    }
    .stage.fill .arc.key-only,
    .stage.preview .arc.key-only {
      display: none;
    }

    @keyframes rotate-arc {
      to { transform: rotate(360deg); }
    }

    .fill-motion-label {
      position: absolute;
      bottom: var(--label-offset);
      transform: translateY(50%);
      font-family: var(--font-mono);
      font-size: clamp(10px, 1.4vmin, 14px);
      color: rgba(255, 255, 255, 0.4);
      letter-spacing: 0.2em;
    }
    .stage.key .fill-motion-label {
      color: transparent; /* Hidden in key, box is solid anyway */
    }

    /* KEY MOTION - Scanning bar (key-specific animation) */
    .key-motion {
      /* Fill mode: gradient background that will be revealed by scanning bar */
      background: linear-gradient(90deg,
        rgba(255, 107, 53, 0.4),
        rgba(0, 212, 255, 0.3),
        rgba(255, 107, 53, 0.4)
      );
      border: 1px solid var(--panel-border);
      border-radius: 2vmin;
      position: relative;
      overflow: hidden;
      --label-offset: 9.55%;
    }
    .stage.key .key-motion {
      /* Key mode: black/transparent, only scanning bar is white */
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid var(--key-seventyfive);
    }

    .scan-bar {
      position: absolute;
      top: 19.1%;
      bottom: 19.1%;
      width: 15%;
      background: rgba(255, 255, 255, 0.15);
      border-radius: 1vmin;
      animation: none;
    }
    .stage.key .scan-bar {
      background: var(--key-white);
    }

    @keyframes scan-move {
      0%, 100% { left: 0%; }
      50% { left: 85%; }
    }

    .scan-bar::before {
      content: '';
      position: absolute;
      inset: 20% 30%;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 0.5vmin;
    }
    .stage.key .scan-bar::before {
      background: var(--key-white);
    }

    .key-motion-label {
      position: absolute;
      bottom: var(--label-offset);
      left: 50%;
      transform: translate(-50%, 50%);
      font-family: var(--font-mono);
      font-size: clamp(10px, 1.4vmin, 14px);
      /* Fill mode: very subtle */
      color: rgba(255, 255, 255, 0.15);
      letter-spacing: 0.2em;
    }
    .stage.key .key-motion-label {
      color: var(--key-white);
    }
    /* Preview: KEY SYNC label visible */
    .stage.preview .key-motion-label {
      color: rgba(255, 255, 255, 0.7);
    }
    /* Preview: scanning bar cuts through gradient - simulates key masking */
    .stage.preview .scan-bar {
      background: rgba(255, 255, 255, 0.95);
      box-shadow: 0 0 20px rgba(var(--fill-accent-rgb), 0.4);
    }

    /* ═══════════════════════════════════════════════════════════════
       FOOTER ZONE - Status bar + PAIRED reveal
       ═══════════════════════════════════════════════════════════════ */

    .audio-status-slot {
      position: absolute;
      top: 50%;
      right: 0;
      width: var(--right-col);
      transform: translateY(-50%);
      display: flex;
      justify-content: center;
      pointer-events: none;
    }

    .footer {
      grid-column: 1 / -1;
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      gap: 2vmin;
      height: clamp(50px, 8vmin, 80px);
      align-items: center;
      position: relative;
    }

    .status-pill {
      background: rgba(0, 0, 0, 0.6);
      border: 1px solid var(--panel-border);
      border-radius: 999px;
      padding: 1.2vmin 2.5vmin;
      font-family: var(--font-mono);
      font-size: clamp(10px, 1.5vmin, 14px);
      color: rgba(255, 255, 255, 0.6);
      white-space: nowrap;
    }
    .stage.key .status-pill {
      /* Solid white so any text shows in combined */
      background: var(--key-ninety);
      border: 1px solid var(--key-seventyfive);
      color: var(--key-white);
    }
    .stage.preview .status-pill {
      background: rgba(0, 0, 0, 0.8);
      color: rgba(255, 255, 255, 0.8);
    }

    .status-left { justify-self: start; }
    .status-right { justify-self: end; }

    /* PAIRED REVEAL - The magic "third mode" indicator

       Fill mode:  Shows colourful gradient pattern
       Key mode:   Shows "PAIRED" as white matte cutout
       Combined:   "PAIRED" text appears in the gradient colours!

       This is the "wow" moment - text that ONLY appears when properly combined
    */
    .paired-reveal {
      position: relative;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0 3vmin;
      border-radius: 1.5vmin;
      overflow: hidden;
      /* Fill mode: animated gradient */
      background: linear-gradient(
        90deg,
        rgba(0, 212, 255, 0.6),
        rgba(255, 107, 53, 0.5),
        rgba(0, 212, 255, 0.6)
      );
      background-size: 200% 100%;
      animation: gradient-shift 3s ease-in-out infinite;
      border: 1px solid var(--panel-border);
    }
    .stage.key .paired-reveal {
      /* Key mode: subtle matte fill */
      background: var(--key-ten);
      border: 1px solid var(--key-seventyfive);
      animation: none;
    }

    @keyframes gradient-shift {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }

    .paired-text {
      font-family: var(--font-mono);
      font-size: clamp(14px, 2.2vmin, 24px);
      font-weight: 700;
      letter-spacing: 0.25em;
      /* Fill mode: text matches background = invisible! */
      color: transparent;
      /* But we use a subtle effect so it's not completely gone */
      text-shadow: 0 0 30px rgba(255, 255, 255, 0.1);
    }
    .stage.key .paired-text {
      /* Key mode: bright white matte */
      color: var(--key-white);
      text-shadow: none;
    }
    /* Preview: PAIRED text revealed! This is the magic moment */
    .stage.preview .paired-text {
      color: #ffffff;
      text-shadow: 0 0 20px rgba(var(--fill-accent-rgb), 0.8);
    }

    /* ═══════════════════════════════════════════════════════════════
       CORNER MARKERS - Quick visual identification
       ═══════════════════════════════════════════════════════════════ */

    .corner-marker {
      position: absolute;
      width: 8vmin;
      height: 8vmin;
      min-width: 50px;
      min-height: 50px;
    }

    .corner-marker::before,
    .corner-marker::after {
      content: '';
      position: absolute;
      background: rgba(255, 255, 255, 0.2);
    }

    .corner-tl { top: var(--bar-height); left: var(--bar-height); }
    .corner-tl::before { top: 0; left: 0; width: 100%; height: 2px; }
    .corner-tl::after { top: 0; left: 0; width: 2px; height: 100%; }

    .corner-tr { top: var(--bar-height); right: var(--bar-height); }
    .corner-tr::before { top: 0; right: 0; width: 100%; height: 2px; }
    .corner-tr::after { top: 0; right: 0; width: 2px; height: 100%; }

    .corner-bl { bottom: var(--bar-height); left: var(--bar-height); }
    .corner-bl::before { bottom: 0; left: 0; width: 100%; height: 2px; }
    .corner-bl::after { bottom: 0; left: 0; width: 2px; height: 100%; }

    .corner-br { bottom: var(--bar-height); right: var(--bar-height); }
    .corner-br::before { bottom: 0; right: 0; width: 100%; height: 2px; }
    .corner-br::after { bottom: 0; right: 0; width: 2px; height: 100%; }

    .stage.key .corner-marker::before,
    .stage.key .corner-marker::after {
      background: var(--key-white);
    }

    /* ═══════════════════════════════════════════════════════════════
       COLOUR BARS STRIP - Broadcast test pattern
       ═══════════════════════════════════════════════════════════════ */

    .colour-bars {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: var(--bar-height);
      display: flex;
    }

    .colour-bars span {
      flex: 1;
      height: 100%;
    }

    .greyscale-bars {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: var(--bar-height);
      display: flex;
    }

    .greyscale-bars span {
      flex: 1;
      height: 100%;
    }

    /* EBU 75% colour bar order */
    .stage.fill .colour-bars span:nth-child(1) { background: #BFBFBF; }
    .stage.fill .colour-bars span:nth-child(2) { background: #BFBF00; }
    .stage.fill .colour-bars span:nth-child(3) { background: #00BFBF; }
    .stage.fill .colour-bars span:nth-child(4) { background: #00BF00; }
    .stage.fill .colour-bars span:nth-child(5) { background: #BF00BF; }
    .stage.fill .colour-bars span:nth-child(6) { background: #BF0000; }
    .stage.fill .colour-bars span:nth-child(7) { background: #0000BF; }
    .stage.fill .colour-bars span:nth-child(8) { background: #000000; }

    /* EBU greyscale bar order */
    .stage.fill .greyscale-bars span:nth-child(1) { background: #E0E0E0; }
    .stage.fill .greyscale-bars span:nth-child(2) { background: #BFBFBF; }
    .stage.fill .greyscale-bars span:nth-child(3) { background: #A0A0A0; }
    .stage.fill .greyscale-bars span:nth-child(4) { background: #808080; }
    .stage.fill .greyscale-bars span:nth-child(5) { background: #606060; }
    .stage.fill .greyscale-bars span:nth-child(6) { background: #404040; }
    .stage.fill .greyscale-bars span:nth-child(7) { background: #202020; }
    .stage.fill .greyscale-bars span:nth-child(8) { background: #000000; }

    .stage.key .colour-bars span,
    .stage.key .greyscale-bars span {
      background: var(--key-white);
    }

    /* Key/Preview: only half-height matte for bars */
    .stage.key .greyscale-bars,
    .stage.preview .greyscale-bars {
      height: calc(var(--bar-height) / 2);
      top: 0;
    }

    .stage.key .colour-bars,
    .stage.preview .colour-bars {
      height: calc(var(--bar-height) / 2);
      bottom: 0;
    }

    /* ═══════════════════════════════════════════════════════════════
       MODE BADGE - Shows current mode in corner (fill only)
       ═══════════════════════════════════════════════════════════════ */

    .mode-badge {
      position: absolute;
      top: calc(var(--safe-margin) + 1vmin);
      left: calc(var(--safe-margin) + 1vmin);
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid var(--panel-border);
      border-radius: 0.8vmin;
      padding: 0.8vmin 1.5vmin;
      font-family: var(--font-mono);
      font-size: clamp(9px, 1.2vmin, 12px);
      color: rgba(255, 255, 255, 0.6);
      letter-spacing: 0.1em;
    }
    .stage.key .mode-badge {
      background: var(--key-white);
      border: none;
      color: var(--key-white);
    }
    .stage.preview .mode-badge {
      background: linear-gradient(135deg, rgba(var(--fill-accent-rgb), 0.3), rgba(var(--fill-secondary-rgb), 0.3));
      color: #ffffff;
    }

    /* ═══════════════════════════════════════════════════════════════
       TIMECODE DISPLAY
       ═══════════════════════════════════════════════════════════════ */

    .timecode {
      font-family: var(--font-mono);
      font-size: clamp(11px, 1.6vmin, 16px);
      color: rgba(255, 255, 255, 0.4);
      letter-spacing: 0.05em;
      font-variant-numeric: tabular-nums;
    }
    .stage.key .timecode {
      color: var(--key-white);
    }

    .timecode-box {
      position: absolute;
      bottom: var(--label-offset, 9.55%);
      transform: translateY(50%);
    }
    .timecode-box.right { right: 6%; }
    .timecode-box.left { left: 6%; }
  </style>
</head>
<body>
  <div id="stage" class="stage">
    <!-- Fill-only background elements -->
    <div class="fill-texture"></div>
    <div class="fill-sweep"></div>

    <!-- Corner markers -->
    <div class="corner-marker corner-tl"></div>
    <div class="corner-marker corner-tr"></div>
    <div class="corner-marker corner-bl"></div>
    <div class="corner-marker corner-br"></div>

    <!-- Mode badge -->
    <!-- <div class="mode-badge" id="modeBadge">MODE: FILL</div> -->

    <!-- Main layout -->
      <div class="layout">
        <!-- Header: FILL and KEY labels -->
      <div class="header">
        <div class="header-left-decor">
          <div class="header-logo" aria-label="TSG logo">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="6478 7030 450 380" role="img" aria-hidden="true">
              <g transform="translate(0, 0)">
                <path stroke="currentColor" stroke-width="5" fill="none" stroke-linecap="round" stroke-linejoin="round" d="M6488 7305h28c14 0 21 45 28 45s13-45 27-45h28c14 0 21 45 28 45s13-45 27-45h28c14 0 21 45 28 45s13-45 27-45h28m0 90h-28c-14 0-21-45-27-45-7 0-14 45-28 45h-28c-14 0-20-45-27-45s-14 45-28 45h-28c-13 0-20-45-27-45s-14 45-28 45h-28" />
                <path stroke="currentColor" stroke-width="5" fill="none" stroke-linecap="round" stroke-linejoin="round" d="M6654 7305h28c14 0 21 45 28 45s13-45 27-45h28c14 0 21 45 28 45s13-45 27-45h28c14 0 21 45 27 45s14-45 28-45h28m0 90h-28c-14 0-21-45-28-45s-13 45-27 45h-28c-14 0-21-45-27-45s-14 45-28 45h-28c-14 0-21-45-27-45-7 0-14 45-28 45h-28" />
                <path fill="currentColor" d="M6538 7269v-199h-51v-31h144v31h-50v199h-43Zm235-164h-43v-7c0-7-2-14-7-19-5-6-12-9-23-9-6 0-11 1-15 3l-9 6-5 10-1 11 1 11c0 3 1 6 3 8l7 7 14 5 33 10c10 3 17 6 23 10 6 3 11 8 14 13 4 5 6 11 7 17l1 23-3 27c-3 8-7 15-13 21s-13 11-23 14a118 118 0 0 1-65 1c-9-3-17-7-23-12-7-5-12-10-16-17-3-6-5-14-5-21v-13h43v11c0 6 2 11 7 16s13 7 24 7l17-2c4-2 7-4 9-7 3-3 4-7 4-11l1-14-1-15c0-4-1-7-3-9-2-3-5-5-8-6l-13-5-31-10c-19-5-31-13-38-23-6-9-9-21-9-36 0-8 1-16 5-24 3-8 7-15 14-20 5-6 13-10 22-14a104 104 0 0 1 63 0c9 3 16 7 23 12 13 10 20 22 20 35v16Zm13-11c0-10 2-18 7-25 4-7 10-13 17-18a98 98 0 0 1 99 0c6 5 12 11 16 18s7 15 7 25v11h-44v-11c0-8-3-14-8-18-6-4-13-6-21-6s-15 2-21 6-8 10-8 18v121c0 8 2 14 8 18a46 46 0 0 0 42 0c5-4 8-10 8-18v-43h-34v-29h78v72c0 10-3 18-7 25s-10 12-16 17c-7 5-15 8-24 11a98 98 0 0 1-52 0c-9-3-17-6-23-11a46 46 0 0 1-23-42v-121Z"/>
              </g>
            </svg>
          </div>
          <div class="header-tagline">
            <span>KEY+FILL</span>
            <span class="header-tagline-strong">ID<span class="mirror-glyph">3</span>NT</span>
            <span>PROGRAMME</span>
          </div>
        </div>
        <div class="header-box header-left">
          <span class="fill-label" id="fillLabel">ID 01 › FILL</span>
        </div>
        <div class="header-box header-right">
          <span class="key-label" id="keyLabel">ID 01 › KEY</span>
        </div>
      </div>

      <!-- Center: ID + Motion panels -->
      <div class="center">
        <div class="id-panel">
          <div class="id-rings"></div>
          <div class="channel-id" id="channelId">01</div>
          <div class="channel-meta" id="channelMeta">FEED IDENT ONE</div>

          <!-- Channel fingerprint - unique visual per channel -->
          <div class="fingerprint" id="fingerprint">
            <div class="fingerprint-ring"></div>
            <!-- 8 segments generated by JS -->
            <div class="fingerprint-radar" id="fingerprintRadar"></div>
            <div class="fingerprint-center">
              <span class="fingerprint-id" id="fingerprintId">1</span>
            </div>
            <div class="fingerprint-labels">
              <span class="fingerprint-label" data-pos="1">1</span>
              <span class="fingerprint-label" data-pos="2">2</span>
              <span class="fingerprint-label" data-pos="3">3</span>
              <span class="fingerprint-label" data-pos="4">4</span>
              <span class="fingerprint-label" data-pos="5">5</span>
              <span class="fingerprint-label" data-pos="6">6</span>
              <span class="fingerprint-label" data-pos="7">7</span>
              <span class="fingerprint-label" data-pos="8">8</span>
            </div>
          </div>
        </div>

        <div class="motion-panel">
          <div class="fill-motion">
            <div class="rotating-arc">
              <div class="arc"></div>
              <div class="arc"></div>
              <div class="arc"></div>
              <div class="arc key-only"></div>
            </div>
            <span class="fill-motion-label">FILL SYNC</span>
          </div>

          <div class="key-motion">
            <div class="scan-bar"></div>
            <span class="key-motion-label">KEY SYNC</span>
            <div class="timecode timecode-box right" id="timecode">88:88:88:88</div>
            <div class="timecode timecode-box left" id="wallclock">88:88:88:88</div>
          </div>
        </div>
      </div>

      <!-- Footer: Status + PAIRED reveal -->
      <div class="footer">
        <div class="status-pill status-left" id="statusLeft">SDI OUTPUT</div>
        <div class="paired-reveal">
          <span class="paired-text">✓ PAIRED</span>
        </div>
        <div class="status-pill status-right" id="statusRight">1920×1080</div>
        <div class="audio-status-slot" id="audioStatusSlot"></div>
      </div>
    </div>

    <!-- Greyscale bars strip -->
    <div class="greyscale-bars">
      <span></span><span></span><span></span><span></span>
      <span></span><span></span><span></span><span></span>
    </div>

    <!-- Colour bars strip -->
    <div class="colour-bars">
      <span></span><span></span><span></span><span></span>
      <span></span><span></span><span></span><span></span>
    </div>
  </div>

  <script>
    (function() {
      'use strict';

      // ═══════════════════════════════════════════════════════════════
      // URL PARAMETER PARSING
      // Format: ?mode=fill&id=1  or  ?mode=key&id=5  or  ?id=3 (preview)
      //
      // Modes:
      //   preview (default) - Combined simulation with checkerboard bg
      //   fill              - RGB output for CasparCG fill channel
      //   key               - Luminance matte for CasparCG key channel
      //   straight          - Straight alpha (browser default)
      // ═══════════════════════════════════════════════════════════════

      function parseParams() {
        const search = window.location.search.replace(/^\?/, '');
        const params = new URLSearchParams(search);
        return {
          mode: params.get('mode'),
          id: params.get('id'),
          audio: params.get('audio')
        };
      }

      const params = parseParams();

      function numberToWord(num) {
        const words = [
          'ONE', 'TWO', 'THREE', 'FOUR', 'FIVE', 'SIX', 'SEVEN', 'EIGHT',
          'NINE', 'TEN', 'ELEVEN', 'TWELVE', 'THIRTEEN', 'FOURTEEN', 'FIFTEEN', 'SIXTEEN'
        ];
        return words[num - 1] || 'ONE';
      }

      // Channel ID (1-16, zero-padded)
      let channelNum = parseInt(params.id || '1', 10);
      if (isNaN(channelNum) || channelNum < 1) channelNum = 1;
      if (channelNum > 16) channelNum = 16;
      let channelId = String(channelNum).padStart(2, '0');

      // Mode: preview (default), fill, key, or straight
      let mode = (params.mode || 'preview').toLowerCase();
      if (!['fill', 'key', 'preview', 'straight'].includes(mode)) mode = 'preview';

      // ═══════════════════════════════════════════════════════════════
      // APPLY CONFIGURATION
      // ═══════════════════════════════════════════════════════════════

      const stage = document.getElementById('stage');
      const modeBadge = document.getElementById('modeBadge');
      const modeLabels = {
        fill: 'Premultiplied Alpha',
        key: 'Premultiplied Alpha',
        preview: 'Premultiplied Alpha Superimposed Preview',
        straight: 'Straight Alpha'
      };
      let audioState = 'OFF';

      function updateStatusLeft() {
        const modeLabel = modeLabels[mode] || modeLabels.preview;
        document.getElementById('statusLeft').textContent =
          `ID: ${channelId} | Audio: ${audioState} | Mode: ${modeLabel}`;
      }
      stage.classList.remove('fill', 'key', 'preview', 'straight');
      stage.classList.add(mode);
      document.body.classList.remove('fill-mode');
      document.documentElement.classList.remove('fill-mode');
      if (mode === 'fill') {
        document.body.classList.add('fill-mode');
        document.documentElement.classList.add('fill-mode');
      }

      // Update text content
      document.getElementById('channelId').textContent = channelId;
      document.getElementById('fillLabel').textContent = `ID ${channelId} › FILL`;
      document.getElementById('keyLabel').textContent = `ID ${channelId} › KEY`;
      if (modeBadge) modeBadge.textContent = `MODE: ${mode.toUpperCase()}`;
      updateStatusLeft();
      document.getElementById('channelMeta').textContent = `FEED IDENT ${numberToWord(channelNum)}`;

      // ═══════════════════════════════════════════════════════════════
      // CHANNEL FINGERPRINT
      // Unique visual identifier per channel for mismatch detection
      // Each channel (1-8) activates its corresponding 45° segment
      // ═══════════════════════════════════════════════════════════════

      const fingerprint = document.getElementById('fingerprint');
      const fingerprintRadar = document.getElementById('fingerprintRadar');
      const fingerprintId = document.getElementById('fingerprintId');
      const labels = document.querySelectorAll('.fingerprint-label');

      // Determine which segment this channel uses (1-8, wrapping for 9-16)
      const segmentIndex = ((channelNum - 1) % 8) + 1;

      // Update fingerprint center ID
      fingerprintId.textContent = segmentIndex;

      // Create 8 segment lines
      for (let i = 1; i <= 8; i++) {
        const segment = document.createElement('div');
        segment.className = 'fingerprint-segment' + (i === segmentIndex ? ' active' : '');
        // Each segment is 45° apart, starting from top (270° in standard coords, or -90°)
        const angle = -90 + (i - 1) * 45;
        segment.style.transform = `rotate(${angle}deg)`;
        fingerprint.insertBefore(segment, fingerprintRadar);
      }

      // Highlight active label
      labels.forEach(label => {
        if (parseInt(label.dataset.pos, 10) === segmentIndex) {
          label.classList.add('active');
        }
      });

      // Replace CSS animation with Date.now()-locked scan position
      function startScanLock() {
        const keyMotion = document.querySelector('.key-motion');
        const scanBar = document.querySelector('.scan-bar');
        if (!keyMotion || !scanBar) return;

        scanBar.style.animation = 'none';
        scanBar.style.transform = 'translateX(0px)';

        let maxX = 0;
        function measure() {
          const boxW = keyMotion.clientWidth;
          const barW = scanBar.getBoundingClientRect().width;
          maxX = Math.max(0, boxW - barW);
        }
        measure();
        if (typeof ResizeObserver !== 'undefined') {
          new ResizeObserver(measure).observe(keyMotion);
        } else {
          window.addEventListener('resize', measure);
        }

        const cycleMs = 2000;
        function tick() {
          const t = Date.now() % cycleMs;
          const p = t / cycleMs;
          const tri = p < 0.5 ? p * 2 : (1 - p) * 2;
          const x = tri * maxX;
          scanBar.style.transform = `translateX(${x}px)`;
          requestAnimationFrame(tick);
        }
        tick();
      }
      startScanLock();

      // Radar animation - starts at channel-specific angle
      // This means if fill and key are mismatched, radars will be out of phase!
      const radarBaseAngle = -90 + (segmentIndex - 1) * 45;

      // Animate radar with channel-specific starting position
      let radarStart = performance.now();
      const radarSpeed = 0.06; // rotations per second

      function animateRadar() {
        const elapsed = performance.now() - radarStart;
        const rotation = radarBaseAngle + (elapsed * radarSpeed * 0.36); // 0.36 = 360/1000
        fingerprintRadar.style.transform = `rotate(${rotation}deg)`;
        requestAnimationFrame(animateRadar);
      }
      requestAnimationFrame(animateRadar);

      // ═══════════════════════════════════════════════════════════════
      // TIMECODE ANIMATION
      // Running timecode for visual confirmation of live output
      // ═══════════════════════════════════════════════════════════════

      const timecodeEl = document.getElementById('timecode');
      const wallclockEl = document.getElementById('wallclock');
      const counterStart = Math.ceil(Date.now() / 1000) * 1000;

      function formatTimecode(ms) {
        const totalSeconds = Math.floor(ms / 1000);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;
        const frames = Math.floor((ms % 1000) / 20); // 50fps

        return [
          String(hours).padStart(2, '0'),
          String(minutes).padStart(2, '0'),
          String(seconds).padStart(2, '0'),
          String(frames).padStart(2, '0')
        ].join(':');
      }

      function formatWallclock(now) {
        const hours = now.getHours();
        const minutes = now.getMinutes();
        const seconds = now.getSeconds();
        const centis = Math.floor(now.getMilliseconds() / 10);
        return [
          String(hours).padStart(2, '0'),
          String(minutes).padStart(2, '0'),
          String(seconds).padStart(2, '0'),
          String(centis).padStart(2, '0')
        ].join(':');
      }

      function updateTimecode() {
        const elapsed = Math.max(0, Date.now() - counterStart);
        timecodeEl.textContent = formatTimecode(elapsed);
        if (wallclockEl) {
          wallclockEl.textContent = formatWallclock(new Date());
        }
      }

      // Tick at 50fps aligned to real time
      const msToNextFrame = Math.max(0, 20 - (Date.now() % 20));
      setTimeout(() => {
        updateTimecode();
        setInterval(updateTimecode, 20);
      }, msToNextFrame);

      function updateCheckerSize() {
        const w = window.innerWidth || 1920;
        const h = window.innerHeight || 1080;
        const size = Math.min(w / 64, h / 36);
        document.documentElement.style.setProperty('--checker-size', `${size}px`);
      }
      updateCheckerSize();
      window.addEventListener('resize', updateCheckerSize);

      // ═══════════════════════════════════════════════════════════════
      // CASPARCG TEMPLATE INTERFACE
      // Supports CG UPDATE for runtime changes
      // ═══════════════════════════════════════════════════════════════

      window.update = function(data) {
        try {
          let parsed = {};

          if (typeof data === 'string') {
            data = data.trim();
            if (data.startsWith('{')) {
              parsed = JSON.parse(data);
            } else if (/^\d+$/.test(data)) {
              parsed = { ch: data };
            } else {
              // Parse as query string
              const pairs = data.replace(/^\?/, '').split('&');
              for (const pair of pairs) {
                const [k, v] = pair.split('=');
                if (k && v) parsed[k] = v;
              }
            }
          } else if (typeof data === 'object') {
            parsed = data;
          }

          // Update channel
          if (parsed.id || parsed.ch || parsed.channel) {
            const newCh = parseInt(parsed.id || parsed.ch || parsed.channel, 10);
            if (!isNaN(newCh) && newCh >= 1 && newCh <= 16) {
              const newId = String(newCh).padStart(2, '0');
              channelNum = newCh;
              channelId = newId;
              document.getElementById('channelId').textContent = newId;
              document.getElementById('fillLabel').textContent = `ID ${newId} › FILL`;
              document.getElementById('keyLabel').textContent = `ID ${newId} › KEY`;
              updateStatusLeft();
              document.getElementById('channelMeta').textContent = `FEED IDENT ${numberToWord(newCh)}`;
            }
          }

          // Update mode
          if (parsed.mode) {
            const newMode = parsed.mode.toLowerCase();
            if (['fill', 'key', 'preview', 'straight'].includes(newMode)) {
              mode = newMode;
              stage.classList.remove('fill', 'key', 'preview', 'straight');
              stage.classList.add(mode);
              document.body.classList.remove('fill-mode');
              document.documentElement.classList.remove('fill-mode');
              if (mode === 'fill') {
                document.body.classList.add('fill-mode');
                document.documentElement.classList.add('fill-mode');
              }
              if (modeBadge) modeBadge.textContent = `MODE: ${mode.toUpperCase()}`;
              updateStatusLeft();
            }
          }
        } catch (e) {
          console.error('Update parse error:', e);
        }
      };

      window.play = function() { /* Optional: trigger animations */ };
      window.stop = function() { /* Optional: stop animations */ };

      // ═══════════════════════════════════════════════════════════════
      // AUDIO IDENT SYSTEM — TSG Broadcast Identifier
      // Pre-rendered MP3 files + Web Audio API with TRUE stereo separation
      //
      // Enable via ?audio=on parameter (default: on for fill/preview/straight)
      //
      // TIMING: Repeats every minute, identical pattern each cycle.
      //
      // Pip sequence (5 pips at :00, :15, :30, :45 each minute):
      //   T-4s: LEFT only        — verify left channel present
      //   T-3s: RIGHT only       — verify right channel present
      //   T-2s: CENTRE NORMAL    — stereo reference
      //   T-1s: CENTRE INVERTED  — phase test (cancels when summed to mono)
      //   T:    CENTRE NORMAL    — long pip marking the boundary
      //
      // MP3 ident schedule (starts 1s after each boundary):
      //   :01 → leftLong   (LEFT)  "Feed X, Left Channel"
      //   :16 → leftShort  (LEFT)  "Left"
      //   :31 → rightLong  (RIGHT) "Feed X, Right Channel"
      //   :46 → rightShort (RIGHT) "Right"
      //
      // Audio files: ./audio/feed-{1-8}-{left,right}-{long,short}.mp3 (48 kHz mono)
      // ═══════════════════════════════════════════════════════════════

      const audioParam = (params.audio || '').toLowerCase();
      const audioEnabled = mode === 'key'
        ? false
        : audioParam === 'on'
          ? true
          : audioParam === 'off'
            ? false
            : (mode === 'fill' || mode === 'preview' || mode === 'straight');

      if (audioEnabled) {
        // Feed number for announcements (1-8)
        const feedNum = ((channelNum - 1) % 8) + 1;

        // Audio context and buffers
        let audioCtx = null;
        let masterGain = null;
        const audioBuffers = {};
        let audioLoaded = false;
        let loadingIndicator = null;
        let loopRunning = false;  // Prevent double loop scheduling

        // File manifest for this feed
        // Resolve audio path relative to current document location
        const basePath = new URL('./audio/', window.location.href).href;
        const audioFiles = {
          leftLong: `${basePath}feed-${feedNum}-left-long.mp3`,
          leftShort: `${basePath}feed-${feedNum}-left-short.mp3`,
          rightLong: `${basePath}feed-${feedNum}-right-long.mp3`,
          rightShort: `${basePath}feed-${feedNum}-right-short.mp3`
        };
        console.log('Audio files:', audioFiles);

        // Initialise audio context
        function initAudio() {
          if (audioCtx) return Promise.resolve();

          audioCtx = new (window.AudioContext || window.webkitAudioContext)();

          // Master gain at -18 dBFS
          masterGain = audioCtx.createGain();
          masterGain.gain.value = 0.126; // 10^(-18/20)
          masterGain.connect(audioCtx.destination);

          return Promise.resolve();
        }

        // Load a single audio file
        async function loadAudioFile(url) {
          try {
            const response = await fetch(url);
            if (!response.ok) {
              console.warn(`Audio file not found: ${url}`);
              return null;
            }
            const arrayBuffer = await response.arrayBuffer();
            return await audioCtx.decodeAudioData(arrayBuffer);
          } catch (e) {
            console.warn(`Failed to load audio: ${url}`, e);
            return null;
          }
        }

        // Load all audio files
        async function loadAllAudio() {
          await initAudio();

          const loadPromises = Object.entries(audioFiles).map(async ([key, url]) => {
            const buffer = await loadAudioFile(url);
            if (buffer) {
              audioBuffers[key] = buffer;
            }
          });

          await Promise.all(loadPromises);

          const loadedCount = Object.keys(audioBuffers).length;
          const totalCount = Object.keys(audioFiles).length;

          console.log(`Audio loaded: ${loadedCount}/${totalCount} files`);
          audioLoaded = loadedCount > 0;

          return audioLoaded;
        }

        // Play audio buffer with HARD stereo panning (L-only or R-only)
        // pan: -1 = LEFT channel only, +1 = RIGHT channel only
        //
        // ROUTING ARCHITECTURE (simple, reliable):
        //   source ──► gain (fade envelope) ──► panner ──► masterGain
        //
        // StereoPanner with mono input and pan=-1 routes ALL audio to LEFT only.
        // This is the Web Audio spec behaviour and works reliably across browsers.
        function playBuffer(buffer, pan, when, callback) {
          if (!buffer || !audioCtx) {
            if (callback) callback();
            return;
          }

          if (audioCtx.state === 'suspended') {
            audioCtx.resume();
          }

          const source = audioCtx.createBufferSource();
          const gain = audioCtx.createGain();
          const panner = audioCtx.createStereoPanner();

          source.buffer = buffer;
          panner.pan.value = pan;  // -1 = full left, +1 = full right

          const startAt = typeof when === 'number' ? when : audioCtx.currentTime;
          const duration = buffer.duration || 0;
          const fade = Math.min(0.01, duration / 2);

          // Fade envelope: 10ms fade in/out
          // MP3 level: +12 dB relative to default (1.0 × 3.981)
          const mp3Gain = 3.981;
          gain.gain.setValueAtTime(0, startAt);
          gain.gain.linearRampToValueAtTime(mp3Gain, startAt + fade);
          gain.gain.setValueAtTime(mp3Gain, startAt + duration - fade);
          gain.gain.linearRampToValueAtTime(0, startAt + duration);

          // Simple signal chain: source → gain → panner → master
          source.connect(gain);
          gain.connect(panner);
          panner.connect(masterGain);

          source.onended = () => {
            if (callback) callback();
          };

          source.start(startAt);
          source.stop(startAt + duration);
        }

        // Play identifying tone with stereo panning and optional phase inversion
        // pan: -1 = full left, 0 = centre, 1 = full right
        // polarity: 1 = normal, -1 = L/R out-of-phase (for mono cancellation test)
        //
        // ROUTING ARCHITECTURE (normal, polarity = 1):
        //   osc ──► toneGain (envelope) ──► panner ──► masterGain
        //
        // ROUTING ARCHITECTURE (phase test, polarity = -1, pan = 0):
        //   osc ──► toneGain (envelope) ──► splitter ──► L: gainL (+1) ──► merger ──► masterGain
        //                                            ──► R: gainR (-1) ──►
        //
        // When polarity = -1 and pan = 0, L and R are in opposite phase.
        // Mono sum (L+R) = 0, providing audible verification of correct phase alignment.
        function playTone(frequency, duration, pan, when, polarity = 1) {
          if (!audioCtx) return;
          if (audioCtx.state === 'suspended') audioCtx.resume();

          const osc = audioCtx.createOscillator();
          const toneGain = audioCtx.createGain();

          osc.type = 'sine';
          osc.frequency.value = frequency;

          // Envelope for smooth start/stop (2ms fade)
          const fade = Math.min(0.002, duration / 2);

          // Phase test mode: L normal, R inverted (cancels to silence in mono)
          if (polarity === -1 && pan === 0) {
            // No centre compensation needed - we route directly to L and R at unity
            toneGain.gain.setValueAtTime(0, when);
            toneGain.gain.linearRampToValueAtTime(1, when + fade);
            toneGain.gain.setValueAtTime(1, when + duration - fade);
            toneGain.gain.linearRampToValueAtTime(0, when + duration);

            // Create separate L/R paths with opposite polarity
            const gainL = audioCtx.createGain();
            const gainR = audioCtx.createGain();
            const merger = audioCtx.createChannelMerger(2);

            gainL.gain.value = 1;   // L: normal phase
            gainR.gain.value = -1;  // R: inverted phase

            // Route: osc → toneGain → split to gainL and gainR → merge to stereo
            osc.connect(toneGain);
            toneGain.connect(gainL);
            toneGain.connect(gainR);
            gainL.connect(merger, 0, 0);  // gainL output → merger L input
            gainR.connect(merger, 0, 1);  // gainR output → merger R input
            merger.connect(masterGain);
          } else {
            // Normal mode: use StereoPanner
            const panner = audioCtx.createStereoPanner();

            // Compensate for StereoPanner equal-power panning loss at centre
            // pan=0 causes -3 dB per channel, so we boost by +3 dB (×1.414) to maintain -18 dBFS
            const centreCompensation = (pan === 0) ? 1.414 : 1.0;

            toneGain.gain.setValueAtTime(0, when);
            toneGain.gain.linearRampToValueAtTime(centreCompensation, when + fade);
            toneGain.gain.setValueAtTime(centreCompensation, when + duration - fade);
            toneGain.gain.linearRampToValueAtTime(0, when + duration);

            panner.pan.value = pan;

            // Signal chain
            osc.connect(toneGain);
            toneGain.connect(panner);
            panner.connect(masterGain);
          }

          osc.start(when);
          osc.stop(when + duration);
        }

        // Schedule pip sequence for stereo channel and phase verification
        // Each session (every 15s) plays 5 pips with different routing:
        //
        //   Pip 1 (T-4): LEFT only        — verify left channel
        //   Pip 2 (T-3): RIGHT only       — verify right channel
        //   Pip 3 (T-2): CENTRE NORMAL    — stereo reference
        //   Pip 4 (T-1): CENTRE INVERTED  — phase test (cancels in mono)
        //   Pip 5 (T):   CENTRE NORMAL    — long pip marking the boundary
        //
        // Listening test:
        //   - Pip 1 should only be audible in left speaker/ear
        //   - Pip 2 should only be audible in right speaker/ear
        //   - Pip 3 should be audible in both channels
        //   - Pip 4 should cancel to silence when summed to mono
        //   - Pip 5 should be audible in both channels (long, marks quarter)
        function schedulePips(whenT) {
          const freq = 1000;
          const shortDur = 0.1;
          const longDur = 0.5;

          // Pip 1: LEFT only (T-4)
          playTone(freq, shortDur, -1, whenT - 4, 1);

          // Pip 2: RIGHT only (T-3)
          playTone(freq, shortDur, 1, whenT - 3, 1);

          // Pip 3: CENTRE, phase NORMAL (T-2)
          playTone(freq, shortDur, 0, whenT - 2, 1);

          // Pip 4: CENTRE, phase INVERTED (T-1)
          playTone(freq, shortDur, 0, whenT - 1, -1);

          // Pip 5: CENTRE, phase NORMAL, long pip (T)
          playTone(freq, longDur, 0, whenT, 1);
        }

        // Schedule MP3 ident clip at T+1s (1 second after the quarter boundary)
        // This allows the long pip at T to complete before the voice ident starts.
        //
        // Pattern: LEFT channel gets both clips first half, RIGHT gets second half
        //   :00 → leftLong   "Feed X, Left Channel"         (LEFT ONLY)
        //   :15 → leftShort  "Left"                         (LEFT ONLY)
        //   :30 → rightLong  "Feed X, Right Channel"        (RIGHT ONLY)
        //   :45 → rightShort "Right"                        (RIGHT ONLY)
        function scheduleIdentClip(whenT, quarterSecond) {
          const clipStart = whenT + 1; // +1s offset from the quarter boundary

          if (quarterSecond === 0) {
            playBuffer(audioBuffers.leftLong, -1, clipStart);   // LEFT
          } else if (quarterSecond === 15) {
            playBuffer(audioBuffers.leftShort, -1, clipStart);  // LEFT
          } else if (quarterSecond === 30) {
            playBuffer(audioBuffers.rightLong, 1, clipStart);   // RIGHT
          } else if (quarterSecond === 45) {
            playBuffer(audioBuffers.rightShort, 1, clipStart);  // RIGHT
          }
        }

        function getNextQuarterBoundaryMs(minLeadMs) {
          const nowMs = Date.now();
          const nowDate = new Date(nowMs);
          const msIntoMinute = (nowDate.getSeconds() * 1000) + nowDate.getMilliseconds();
          const quarterMarks = [0, 15000, 30000, 45000, 60000];
          let nextMsInMinute = quarterMarks.find(q => q - msIntoMinute >= minLeadMs);
          if (nextMsInMinute === undefined) {
            nextMsInMinute = 60000;
          }
          const minuteStartMs = nowMs - msIntoMinute;
          return minuteStartMs + nextMsInMinute;
        }

        function scheduleIdentLoop() {
          if (!audioLoaded || !audioCtx) return;
          if (loopRunning) return;  // Prevent double scheduling on init
          loopRunning = true;

          function tick() {
            if (!audioLoaded || !audioCtx) return;

            if (audioState !== 'ON') {
              audioState = 'ON';
              updateStatusLeft();
            }

            const nextQuarterMs = getNextQuarterBoundaryMs(6000);  // 6s lead time for 5 pips
            const nowMs = Date.now();
            const msUntilNext = nextQuarterMs - nowMs;
            const ctxNow = audioCtx.currentTime;
            const whenT = ctxNow + (msUntilNext / 1000);
            const quarterSecond = new Date(nextQuarterMs).getSeconds();

            console.log(`Audio ident: next quarter :${String(quarterSecond).padStart(2, '0')} in ${Math.round(msUntilNext / 1000)}s`);

            // Pips (L → R → C → invC → C-long) + ident clip (+1s offset)
            schedulePips(whenT);
            scheduleIdentClip(whenT, quarterSecond);

            // Schedule the next tick after this quarter's long pip
            const nextTickDelay = msUntilNext + 600;
            setTimeout(tick, Math.max(1000, nextTickDelay));
          }

          tick();
        }

        // Show loading indicator
        function showLoadingIndicator() {
          loadingIndicator = document.createElement('div');
          loadingIndicator.style.cssText = `
            position: absolute;
            top: calc(var(--safe-margin) + 1vmin);
            right: calc(var(--safe-margin) + 1vmin);
            background: linear-gradient(135deg, rgba(255, 180, 0, 0.9), rgba(200, 140, 0, 0.9));
            border-radius: 0.8vmin;
            padding: 0.8vmin 1.5vmin;
            font-family: var(--font-mono);
            font-size: clamp(9px, 1.2vmin, 12px);
            color: #ffffff;
            letter-spacing: 0.1em;
          `;
          loadingIndicator.textContent = '⏳ LOADING AUDIO...';
          const slot = document.getElementById('audioStatusSlot');
          if (slot) {
            loadingIndicator.style.position = 'static';
            loadingIndicator.style.top = 'auto';
            loadingIndicator.style.right = 'auto';
            slot.appendChild(loadingIndicator);
          } else {
            document.getElementById('stage').appendChild(loadingIndicator);
          }
        }

        // Show prompt if audio context needs user interaction
        let promptEl = null;

        function showAudioPrompt() {
          const prompt = document.createElement('div');
          prompt.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid var(--fill-accent);
            border-radius: 2vmin;
            padding: 4vmin;
            text-align: center;
            z-index: 9999;
            cursor: pointer;
            font-family: var(--font-mono);
          `;
          prompt.innerHTML = `
            <div style="font-size: 3vmin; color: var(--fill-accent); margin-bottom: 2vmin; display:inline-flex; align-items:center; gap:1vmin;">
              <span style="display:inline-block; transform: scaleX(-1);">🔊</span>
              <span>AUDIO IDENT</span>
              <span>🔊</span>
            </div>
            <div style="font-size: 1.8vmin; color: #ffffff; margin-bottom: 2vmin;">
              Click to enable audio identification
            </div>
            <div style="font-size: 1.2vmin; color: rgba(255,255,255,0.5);">
              Browser requires user interaction for audio playback
            </div>
          `;

          prompt.addEventListener('click', () => {
            audioCtx.resume().then(() => {
              prompt.remove();
              promptEl = null;
              scheduleIdentLoop();
            });
          });

          document.body.appendChild(prompt);
          promptEl = prompt;
        }

        // Ready indicator intentionally removed (no on-screen audio badge)

        // Show error indicator
        function showErrorIndicator() {
          if (loadingIndicator) {
            loadingIndicator.style.background = 'linear-gradient(135deg, rgba(255, 80, 80, 0.9), rgba(200, 50, 50, 0.9))';
            loadingIndicator.textContent = '⚠️ AUDIO FILES NOT FOUND';
            const slot = document.getElementById('audioStatusSlot');
            if (slot && loadingIndicator.parentElement !== slot) {
              loadingIndicator.style.position = 'static';
              loadingIndicator.style.top = 'auto';
              loadingIndicator.style.right = 'auto';
              slot.appendChild(loadingIndicator);
            }
          }
          audioState = 'OFF';
          updateStatusLeft();
        }

        // ═══════════════════════════════════════════════════════════════
        // UK PSTN RINGBACK TONE GENERATOR
        //
        // Generates the distinctive British "ring ring... ring ring" tone
        // using Web Audio API oscillators (no external assets).
        //
        // TONE: Sum of 400 Hz + 450 Hz sine waves, mixed equally
        //       (per ITU-T E.180 / BS 6305 / BT specification)
        //
        // TRIGGERS: Every minute at exactly xx:21.000 and xx:51.000
        //           Uses identical timebase logic to pip/MP3 scheduling
        //
        // CADENCE: Two "pip-pip" pairs per trigger (total 4.0s):
        //   ON  0.4s  ─┐
        //   OFF 0.2s   │ First double-pip
        //   ON  0.4s  ─┘
        //   OFF 2.0s     Gap between pairs
        //   ON  0.4s  ─┐
        //   OFF 0.2s   │ Second double-pip
        //   ON  0.4s  ─┘
        //
        // TIMING:
        //   Trigger at xx:21.000 ends at xx:25.000
        //   Trigger at xx:51.000 ends at xx:55.000
        //
        // Outside these windows, output is silent (0 gain).
        // ═══════════════════════════════════════════════════════════════

        let ringbackLoopRunning = false;

        // Play UK PSTN ringback tone cadence starting at `whenStart` (audioCtx time)
        // Creates two oscillators (400 Hz + 450 Hz) and schedules gain envelope
        // for the precise ON/OFF pattern.
        // pan: -1 = LEFT only (xx:00-xx:29), +1 = RIGHT only (xx:30-xx:59)
        function playRingbackTone(whenStart, pan) {
          if (!audioCtx) return;
          if (audioCtx.state === 'suspended') audioCtx.resume();

          // Two oscillators for the characteristic UK ringback sound
          const osc400 = audioCtx.createOscillator();
          const osc450 = audioCtx.createOscillator();
          const oscGain = audioCtx.createGain();
          const panner = audioCtx.createStereoPanner();

          osc400.type = 'sine';
          osc400.frequency.value = 400;
          osc450.type = 'sine';
          osc450.frequency.value = 450;

          // Stereo position: LEFT for :21, RIGHT for :51
          panner.pan.value = pan;

          // Mix both oscillators equally into the gain node, then through panner
          osc400.connect(oscGain);
          osc450.connect(oscGain);
          oscGain.connect(panner);
          panner.connect(masterGain);

          // Cadence timings (seconds from whenStart):
          // ON intervals: [0.0, 0.4], [0.6, 1.0], [3.0, 3.4], [3.6, 4.0]
          const onIntervals = [
            { start: 0.0, end: 0.4 },
            { start: 0.6, end: 1.0 },
            { start: 3.0, end: 3.4 },
            { start: 3.6, end: 4.0 }
          ];

          // Very short fade (2ms) to avoid clicks
          const fade = 0.002;

          // Start at zero gain (silent)
          oscGain.gain.setValueAtTime(0, whenStart);

          // Ringback level: -3 dB relative to default (0.5 × 0.708 = 0.354)
          const ringbackGain = 0.354;

          // Schedule each ON interval with fade in/out
          for (const interval of onIntervals) {
            const tOn = whenStart + interval.start;
            const tOff = whenStart + interval.end;

            // Ensure we're at 0 just before fade-in
            oscGain.gain.setValueAtTime(0, tOn);
            // Fade in
            oscGain.gain.linearRampToValueAtTime(ringbackGain, tOn + fade);
            // Hold
            oscGain.gain.setValueAtTime(ringbackGain, tOff - fade);
            // Fade out
            oscGain.gain.linearRampToValueAtTime(0, tOff);
          }

          // Start oscillators and stop after the full 4.0s duration
          const totalDuration = 4.0;
          osc400.start(whenStart);
          osc450.start(whenStart);
          osc400.stop(whenStart + totalDuration);
          osc450.stop(whenStart + totalDuration);
        }

        // Find the next ringback trigger time (xx:21 or xx:51 seconds)
        // minLeadMs: minimum milliseconds of lead time needed for scheduling
        // Returns: Unix timestamp (ms) of the next trigger
        function getNextRingbackTriggerMs(minLeadMs) {
          const nowMs = Date.now();
          const nowDate = new Date(nowMs);
          const secondsIntoMinute = nowDate.getSeconds();
          const msIntoSecond = nowDate.getMilliseconds();
          const msIntoMinute = (secondsIntoMinute * 1000) + msIntoSecond;

          // Ringback triggers at 21000ms and 51000ms into each minute
          const triggerMarks = [21000, 51000, 81000]; // 81000 = next minute's :21
          const minLead = minLeadMs || 0;

          let nextMsInMinute = triggerMarks.find(t => (t - msIntoMinute) >= minLead);

          if (nextMsInMinute === undefined) {
            // Wrap to next minute's :21
            nextMsInMinute = 81000;
          }

          const minuteStartMs = nowMs - msIntoMinute;

          // Handle wrap-around: if nextMsInMinute >= 60000, it's in the next minute
          if (nextMsInMinute >= 60000) {
            return minuteStartMs + nextMsInMinute;
          }

          return minuteStartMs + nextMsInMinute;
        }

        // Ringback scheduling loop - runs independently of pip/MP3 loop
        // Uses identical timebase logic for synchronisation
        function scheduleRingbackLoop() {
          if (!audioCtx) return;
          if (ringbackLoopRunning) return;
          ringbackLoopRunning = true;

          function tick() {
            if (!audioCtx) return;

            // Need at least 100ms lead time for scheduling
            const nextTriggerMs = getNextRingbackTriggerMs(100);
            const nowMs = Date.now();
            const msUntilTrigger = nextTriggerMs - nowMs;
            const ctxNow = audioCtx.currentTime;
            const whenStart = ctxNow + (msUntilTrigger / 1000);
            const triggerSecond = new Date(nextTriggerMs).getSeconds();

            // Pan: LEFT for :00-:29, RIGHT for :30-:59
            const pan = triggerSecond < 30 ? -1 : 1;
            const side = pan < 0 ? 'LEFT' : 'RIGHT';
            console.log(`Ringback: next trigger :${String(triggerSecond).padStart(2, '0')} (${side}) in ${(msUntilTrigger / 1000).toFixed(1)}s`);

            // Schedule the ringback tone with stereo position
            playRingbackTone(whenStart, pan);

            // Schedule next tick after this tone completes (4.0s duration + 500ms buffer)
            const nextTickDelay = msUntilTrigger + 4500;
            setTimeout(tick, Math.max(1000, nextTickDelay));
          }

          tick();
        }

        // Initialise
        showLoadingIndicator();
        loadAllAudio().then(success => {
          if (success) {
            if (loadingIndicator) {
              loadingIndicator.remove();
            }

            showAudioPrompt();
            audioCtx.resume().then(() => {
              if (audioCtx.state === 'running') {
                if (promptEl) {
                  promptEl.remove();
                  promptEl = null;
                }
                scheduleIdentLoop();
                scheduleRingbackLoop();  // Start ringback alongside ident loop
              }
            }).catch(() => {
              // Keep prompt visible until user interaction.
            });
          } else {
            showErrorIndicator();
          }
        });
      }

    })();
  </script>
</body>
</html>
